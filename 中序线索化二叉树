#include<stdio.h>
#include<stdlib.h>
#define MAXSIZE 100
typedef char ElemType;
//线索二叉树节点结构
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
    int ltag,rtag;
}*root,*p;
//线索二叉树节点指针
typedef struct BiTNode *BiTree;

//先序创建二叉树,先不管线索,
//后面在遍历的时候在进行添,
//先序建立二叉树 
void CreatBiTreePreOrder(struct BiTNode **root){
    ElemType x;
    scanf("%c",&x);
    if(x=='@'){
        (*root)=NULL;
    }else{
        (*root)=(BiTree)malloc(sizeof(struct BiTNode));
        (*root)->data=x;
        CreatBiTreePreOrder(&(*root)->lchild);
        CreatBiTreePreOrder(&(*root)->rchild);
    }
}
//中序遍历二叉树
void InOrderTraverse(BiTree t){
    if(t){
        InOrderTraverse(t->lchild);
        printf("%c",t->data);
        InOrderTraverse(t->rchild);
    }
    return;
}
//中序遍历二叉树的同时将其中序线索化
//中序线索二叉树
void InOrderTraverseThread(BiTree t){
	printf("\n");
	int top=0;//栈指针置空
	BiTree s[MAXSIZE+1],pre=NULL; //指针栈 
	do{
		while(t){
			s[++top]=t;
			t=t->lchild;
		}
		if(top){
			t=s[top--];
			printf("%c",t->data);
			
			if(t->lchild!=NULL){
				t->ltag=0;
			}else{
				t->ltag=1;
				t->lchild=pre; 
			}
			
			
			
			//!!!!!!!!!!!!!!!
			if(pre!=NULL){
				if(pre->rchild!=NULL){
					pre->rtag=0;
				}else{
					pre->rtag=1;
					pre->rchild=t;
				}
			}
			//!!!!!!!!!!!!!!!
			
			pre=t;
			t=t->rchild;
			
				
		}
		
	}while(top||t);
	pre->rtag=1;
	return;
} 
//中序线索二叉树的遍历





 
int main(){
    BiTree T;
    //首先先序创建一颗二叉树
    CreatBiTreePreOrder(&T);
    //中序遍历
    InOrderTraverse(T);
    //中序线索化二叉树
	InOrderTraverseThread(T); 
	//遍历先序线索二叉树 	
    return 0;
}
